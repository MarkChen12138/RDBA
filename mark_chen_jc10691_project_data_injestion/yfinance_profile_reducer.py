#!/usr/bin/env python3
"""
Reducer for the Yahoo Finance profiling job.

Aggregates ticker-level statistics generated by the mapper and prints
one JSON blob per ticker.
"""

from __future__ import annotations

import json
import sys
from typing import Dict, Optional


def merge_dict(target: Dict[str, int], incoming: Dict[str, int]) -> None:
    for key, value in incoming.items():
        if key in (None, "null"):
            continue
        target[key] = target.get(key, 0) + int(value)


def merge_payload(acc: Dict[str, object], payload: Dict[str, object]) -> None:
    acc["count"] += payload.get("count", 0)

    for field in ("value", "volume"):
        sum_key = f"{field}_sum"
        count_key = f"{field}_count"
        min_key = f"{field}_min"
        max_key = f"{field}_max"

        acc[sum_key] += payload.get(sum_key, 0.0)
        acc[count_key] += payload.get(count_key, 0)

        incoming_min = payload.get(min_key)
        if incoming_min is not None:
            acc[min_key] = (
                incoming_min
                if acc[min_key] is None
                else min(acc[min_key], incoming_min)
            )

        incoming_max = payload.get(max_key)
        if incoming_max is not None:
            acc[max_key] = (
                incoming_max
                if acc[max_key] is None
                else max(acc[max_key], incoming_max)
            )

    merge_dict(acc["series_labels"], payload.get("series_labels", {}))
    merge_dict(acc["value_sources"], payload.get("value_sources", {}))
    merge_dict(acc["missing"], payload.get("missing", {}))

    date_min = payload.get("date_min")
    if date_min:
        acc["date_min"] = min(acc["date_min"], date_min) if acc["date_min"] else date_min

    date_max = payload.get("date_max")
    if date_max:
        acc["date_max"] = max(acc["date_max"], date_max) if acc["date_max"] else date_max


def make_result(agg: Dict[str, object]) -> Dict[str, object]:
    def avg(sum_key: str, count_key: str) -> Optional[float]:
        count = agg[count_key]
        return round(agg[sum_key] / count, 6) if count else None

    result = {
        "row_count": agg["count"],
        "first_date": agg["date_min"],
        "last_date": agg["date_max"],
        "value": {
            "non_null": agg["value_count"],
            "avg": avg("value_sum", "value_count"),
            "min": agg["value_min"],
            "max": agg["value_max"],
        },
        "volume": {
            "non_null": agg["volume_count"],
            "avg": avg("volume_sum", "volume_count"),
            "min": agg["volume_min"],
            "max": agg["volume_max"],
        },
        "series_labels": agg["series_labels"],
        "value_sources": agg["value_sources"],
        "missing_fields": agg["missing"],
    }

    return result


def emit(key: str, agg: Dict[str, object]) -> None:
    result = make_result(agg)
    print(f"{key}\t{json.dumps(result, separators=(',', ':'))}")


def init_state(payload: Dict[str, object]) -> Dict[str, object]:
    return {
        "count": payload.get("count", 0),
        "value_sum": payload.get("value_sum", 0.0),
        "value_count": payload.get("value_count", 0),
        "value_min": payload.get("value_min"),
        "value_max": payload.get("value_max"),
        "value_sources": dict(payload.get("value_sources", {})),
        "volume_sum": payload.get("volume_sum", 0.0),
        "volume_count": payload.get("volume_count", 0),
        "volume_min": payload.get("volume_min"),
        "volume_max": payload.get("volume_max"),
        "series_labels": dict(payload.get("series_labels", {})),
        "missing": dict(payload.get("missing", {})),
        "date_min": payload.get("date_min"),
        "date_max": payload.get("date_max"),
    }


def main() -> None:
    current_key: str | None = None
    current_state: Dict[str, object] | None = None

    for line in sys.stdin:
        if not line.strip():
            continue
        try:
            key, raw = line.rstrip("\n").split("\t", 1)
        except ValueError:
            continue
        payload = json.loads(raw)

        if current_key is None:
            current_key = key
            current_state = init_state(payload)
            continue

        if key != current_key:
            if current_state is not None:
                emit(current_key, current_state)
            current_key = key
            current_state = init_state(payload)
        else:
            merge_payload(current_state, payload)  # type: ignore[arg-type]

    if current_key is not None and current_state is not None:
        emit(current_key, current_state)


if __name__ == "__main__":
    main()
